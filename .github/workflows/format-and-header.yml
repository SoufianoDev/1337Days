name: Update 42 Headers & Format Code (Full Code Protection)

on:
  push:
    branches: [main]

jobs:
  update-headers-and-format:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # This ensures we get full git history

      - name: Setup Git
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Install Python and c-formatter-42
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-pip
          pip3 install c-formatter-42

      - name: Process Headers and Format Code (Full Code Protection)
        run: |
          set -eo pipefail
          author="SoufianoDev"
          header_email="contact.devsoufiano@gmail.com"
          updated=$(date +"%Y/%m/%d %H:%M:%S")
          target_length=85
          ref_filename="ft_putchar.c"
          ruler="/*   $ref_filename"
          template_line="$ruler                                               :+:      :+:    :+:  */"
          spaces_str=${template_line#"$ruler"}
          spaces_str=${spaces_str%%:+:*}
          reserved_space=${#spaces_str}
          suffix=":+:      :+:    :+:  */"

          # Function to get the most accurate creation date
          get_creation_date() {
            local file="$1"
            local git_first_commit=""
            local filesystem_creation=""
            
            # Try to get first commit date from git history
            git_first_commit=$(git log --reverse --format="%ad" --date=format:"%Y/%m/%d %H:%M:%S" -- "$file" 2>/dev/null | head -n1 || echo "")
            
            # Get filesystem creation time (as fallback, but less reliable)
            if command -v stat >/dev/null 2>&1; then
              # Linux/Unix systems
              filesystem_creation=$(stat -c "%W" "$file" 2>/dev/null || echo "")
              if [ "$filesystem_creation" != "" ] && [ "$filesystem_creation" != "0" ]; then
                filesystem_creation=$(date -d "@$filesystem_creation" +"%Y/%m/%d %H:%M:%S" 2>/dev/null || echo "")
              else
                filesystem_creation=""
              fi
            fi
            
            # Prefer git history over filesystem metadata
            if [ -n "$git_first_commit" ]; then
              echo "$git_first_commit"
            elif [ -n "$filesystem_creation" ]; then
              echo "$filesystem_creation"
            else
              # Ultimate fallback to current date
              echo "$(date +"%Y/%m/%d %H:%M:%S")"
            fi
          }

          # Comprehensive Code Elements Protection Function
          protect_all_code_elements() {
            local content="$1"
            local placeholders_file=$(mktemp)
            local counter=0
            
            echo "üõ°Ô∏è  Starting comprehensive code protection..."
            
            # Define ALL code element patterns for complete protection
            local protection_patterns=(
              # 1. DATA TYPES (Basic & Advanced)
              '\bint\b' '\bchar\b' '\bfloat\b' '\bdouble\b' '\bvoid\b'
              '\blong\b' '\bshort\b' '\bunsigned\b' '\bsigned\b' '\bconst\b'
              '\bstatic\b' '\bextern\b' '\bregister\b' '\bvolatile\b' '\binline\b'
              '\bint8_t\b' '\bint16_t\b' '\bint32_t\b' '\bint64_t\b'
              '\buint8_t\b' '\buint16_t\b' '\buint32_t\b' '\buint64_t\b'
              '\bsize_t\b' '\bssize_t\b' '\bptrdiff_t\b' '\bintptr_t\b' '\buintptr_t\b'
              '\bFILE\b' '\bDIR\b' '\bpid_t\b' '\buid_t\b' '\bgid_t\b' '\bmode_t\b'
              '\bt_[a-zA-Z_][a-zA-Z0-9_]*\b'
              
              # 2. CONTROL STRUCTURES & KEYWORDS
              '\bif\b' '\belse\b' '\belif\b' '\bswitch\b' '\bcase\b' '\bdefault\b'
              '\bwhile\b' '\bfor\b' '\bdo\b' '\bbreak\b' '\bcontinue\b'
              '\breturn\b' '\bgoto\b' '\btypedef\b' '\bstruct\b' '\bunion\b' '\benum\b'
              '\bsizeof\b' '\btypeof\b' '\b__typeof__\b'
              
              # 3. PREPROCESSOR DIRECTIVES
              '^[ \t]*#[ \t]*include\b.*$'
              '^[ \t]*#[ \t]*define\b.*$'
              '^[ \t]*#[ \t]*undef\b.*$'
              '^[ \t]*#[ \t]*if\b.*$'
              '^[ \t]*#[ \t]*ifdef\b.*$'
              '^[ \t]*#[ \t]*ifndef\b.*$'
              '^[ \t]*#[ \t]*else\b.*$'
              '^[ \t]*#[ \t]*elif\b.*$'
              '^[ \t]*#[ \t]*endif\b.*$'
              '^[ \t]*#[ \t]*pragma\b.*$'
              '^[ \t]*#[ \t]*error\b.*$'
              '^[ \t]*#[ \t]*warning\b.*$'
              
              # 4. OPERATORS (All types)
              '\+\+' '\--' '\+=' '\-=' '\*=' '\/=' '%=' '&=' '\|=' '\^='
              '<<=' '>>=' '==' '!=' '<=' '>=' '&&' '\|\|' '<<' '>>'
              '->' '\.' '&' '\|' '\^' '~' '!' '%' '\?' ':'
              
              # 5. FUNCTION CALLS & DEFINITIONS
              '\b[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\('
              '\b[a-zA-Z_][a-zA-Z0-9_]*[ \t]+[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\([^)]*\)[ \t]*{'
              
              # 6. STRING LITERALS & CHARACTER CONSTANTS
              '"([^"\\\\]|\\\\.)*"'
              "'([^'\\\\]|\\\\.)*'"
              
              # 7. NUMERIC CONSTANTS
              '\b[0-9]+\.[0-9]*[fFlL]?\b'
              '\b[0-9]*\.[0-9]+[fFlL]?\b'
              '\b[0-9]+[uUlL]*\b'
              '\b0[xX][0-9a-fA-F]+[uUlL]*\b'
              '\b0[0-7]+[uUlL]*\b'
              
              # 8. POINTER & ARRAY OPERATIONS
              '\*[a-zA-Z_][a-zA-Z0-9_]*'
              '&[a-zA-Z_][a-zA-Z0-9_]*'
              '[a-zA-Z_][a-zA-Z0-9_]*\[[^\]]*\]'
              
              # 9. VARIABLE NAMES & IDENTIFIERS
              '\b[a-zA-Z_][a-zA-Z0-9_]*\b'
              
              # 10. COMPLEX EXPRESSIONS
              '[a-zA-Z_][a-zA-Z0-9_]*[ \t]*=[ \t]*[^;]+;'
              '[a-zA-Z_][a-zA-Z0-9_]*[ \t]*[+\-*/][ \t]*[^;]+;'
              
              # 11. FUNCTION POINTER DECLARATIONS
              '\b\w+\s*\(\s*\*\s*\w+\s*\)\s*\([^)]*\)'
              
              # 12. STRUCT/UNION/ENUM DEFINITIONS
              '\bstruct\s+\w*\s*\{[^}]*\}'
              '\bunion\s+\w*\s*\{[^}]*\}'
              '\benum\s+\w*\s*\{[^}]*\}'
              
              # 13. MACRO USAGE
              '\b[A-Z_][A-Z0-9_]*\b'
              
              # 14. TYPEDEF DECLARATIONS
              '\btypedef\s+\w+\s+\w+\s*\{[^}]*\}'
            )

            
            echo "$content" > /tmp/original_content_full
            local working_content="$content"
            
            # Step 1: Protect critical code elements with placeholders
            echo "üîí Protecting ${#protection_patterns[@]} code element patterns..."
            
            for pattern in "${protection_patterns[@]}"; do
              local matches_found=0
              # Use grep with Perl-compatible regex for better pattern matching
              while IFS= read -r match_line; do
                if [ -n "$match_line" ]; then
                  # Extract the actual match
                  local match=$(echo "$match_line" | grep -oE "$pattern" | head -n1)
                  if [ -n "$match" ] && [ "$match" != " " ] && [ ${#match} -gt 1 ]; then
                    local placeholder="__PROTECTED_CODE_${counter}__"
                    echo "$placeholder|$match" >> "$placeholders_file"
                    
                    # Create a safe sed pattern
                    local safe_match=$(printf '%s\n' "$match" | sed 's/[[\.*^$()+?{|\\]/\\&/g')
                    working_content=$(echo "$working_content" | sed "0,/$safe_match/s//$placeholder/")
                    
                    ((counter++))
                    ((matches_found++))
                  fi
                fi
              done <<< "$(echo "$working_content" | grep -E "$pattern" 2>/dev/null || true)"
              
              if [ $matches_found -gt 0 ]; then
                echo "   ‚úì Protected $matches_found instances of pattern: $pattern"
              fi
            done
            
            echo "üéØ Total protected code elements: $counter"
            echo "$working_content"
            echo "PLACEHOLDERS_FILE:$placeholders_file" >&2
          }

          # Function to restore all protected code elements
          restore_all_code_elements() {
            local content="$1"
            local placeholders_file="$2"
            local restored_content="$content"
            local restored_count=0
            
            if [ -f "$placeholders_file" ] && [ -s "$placeholders_file" ]; then
              echo "üîì Restoring all protected code elements..."
              
              # Sort placeholders by number (descending) to avoid conflicts
              sort -t'_' -k3 -nr "$placeholders_file" > "${placeholders_file}_sorted"
              
              while IFS='|' read -r placeholder original; do
                if [ -n "$placeholder" ] && [ -n "$original" ]; then
                  # Check if placeholder exists before replacement
                  if echo "$restored_content" | grep -q "$placeholder"; then
                    restored_content=$(echo "$restored_content" | sed "s|$placeholder|$original|g")
                    ((restored_count++))
                  fi
                fi
              done < "${placeholders_file}_sorted"
              
              echo "‚úÖ Successfully restored $restored_count code elements"
              rm -f "$placeholders_file" "${placeholders_file}_sorted"
            else
              echo "‚ö†Ô∏è  No placeholders file found for restoration"
            fi
            
            echo "$restored_content"
          }

          # Minimal Safe Formatter (Only Basic Indentation)
          format_42_code_minimal() {
            local file="$1"
            local temp_file=$(mktemp)
            local header_lines=""
            local code_content=""
            local placeholders_file=""
            
            echo "üé® Starting minimal safe formatting for: $(basename "$file")"
            
            # STEP 1: Separate header from code
            if head -n 1 "$file" | grep -q "/\* \*\*\*"; then
              local header_end_line=$(grep -n "/\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*/" "$file" | tail -n 1 | cut -d: -f1)
              
              if [ -n "$header_end_line" ] && [ "$header_end_line" -gt 0 ]; then
                local total_header_lines=$((header_end_line + 1))
                if sed -n "${total_header_lines}p" "$file" | grep -q "^$"; then
                  total_header_lines=$((total_header_lines + 1))
                fi
                
                header_lines=$(head -n "$total_header_lines" "$file")
                code_content=$(tail -n +$((total_header_lines + 1)) "$file")
              else
                header_lines=$(head -n 12 "$file")
                code_content=$(tail -n +13 "$file")
              fi
              
              echo "üõ°Ô∏è  Header protected (${total_header_lines:-12} lines)"
            else
              echo "üìù No header found - processing entire file"
              header_lines=""
              code_content=$(cat "$file")
            fi
            
            # STEP 2: Protect ALL code elements
            local protected_content
            protected_content=$(protect_all_code_elements "$code_content" 2>/tmp/placeholders_stderr_full)
            placeholders_file=$(grep "PLACEHOLDERS_FILE:" /tmp/placeholders_stderr_full 2>/dev/null | cut -d: -f2- || echo "")
            
            # STEP 3: Apply ONLY basic indentation (minimal changes)
            local formatted_code
            formatted_code=$(echo "$protected_content" | awk '
            BEGIN {
              indent_level = 0
              prev_was_opening_brace = 0
              prev_was_closing_brace = 0
            }
            
            # Skip empty lines as-is
            /^[ \t]*$/ { 
              print ""
              next 
            }
            
            # Skip lines that are only protected placeholders
            /^[ \t]*__PROTECTED_CODE_[0-9]+__[ \t]*$/ {
              print $0
              next
            }
            
            # Handle lines with opening braces
            /{/ {
              # Remove leading whitespace
              gsub(/^[ \t]+/, "")
              
              # Apply current indentation
              for(i=0; i<indent_level; i++) printf "\t"
              print $0
              
              # Increase indent for next lines if opening brace
              if (/{$/ || /{\s*$/) {
                indent_level++
              }
              next
            }
            
            # Handle lines with closing braces
            /}/ {
              # Decrease indent before this line
              if (/^[ \t]*}/) {
                indent_level--
                if (indent_level < 0) indent_level = 0
              }
              
              # Remove leading whitespace
              gsub(/^[ \t]+/, "")
              
              # Apply indentation
              for(i=0; i<indent_level; i++) printf "\t"
              print $0
              next
            }
            
            # Handle all other lines (minimal changes)
            {
              # Remove only leading whitespace
              gsub(/^[ \t]+/, "")
              
              # Apply indentation if line has content
              if (length($0) > 0) {
                for(i=0; i<indent_level; i++) printf "\t"
                print $0
              } else {
                print ""
              }
            }
            ')
            
            # STEP 4: Restore ALL protected code elements
            if [ -n "$placeholders_file" ]; then
              formatted_code=$(restore_all_code_elements "$formatted_code" "$placeholders_file")
            fi
            
            # STEP 5: Reassemble file
            if [ -n "$header_lines" ]; then
              echo "üîó Reassembling: Header + Protected Code"
              {
                echo "$header_lines"
                echo ""
                echo "$formatted_code"
              } > "$temp_file"
            else
              echo "üíæ Saving protected code (no header)"
              echo "$formatted_code" > "$temp_file"
            fi
            
            # Replace original file
            mv "$temp_file" "$file"
            
            # Cleanup
            rm -f /tmp/placeholders_stderr_full /tmp/original_content_full
            
            echo "‚úÖ Minimal safe formatting completed for $(basename "$file")"
          }

          # Process all C files
          echo "üöÄ Starting comprehensive code protection and formatting..."
          echo "========================================================"
          
          file_count=0
          while IFS= read -r -d '' file; do
            ((file_count++))
            echo ""
            echo "üìÅ File $file_count: Processing $(basename "$file")"
            echo "   Full path: $file"
            
            filename=$(basename "$file")
            filename_len=${#filename}
            diff_len=$(( filename_len - ${#ref_filename} ))
            spaces_after=$(( reserved_space - diff_len ))
            (( spaces_after < 0 )) && spaces_after=0
            new_ruler="/*   $filename"
            new_line=$(printf "%s%*s%s" "$new_ruler" "$spaces_after" "" "$suffix")

            # STEP 1: Handle Header Logic (Preserve Original)
            echo "   üè∑Ô∏è  Processing header..."
            if head -n 1 "$file" | grep -q "/\* \*\*\*"; then
              # Get the accurate creation date for comparison
              accurate_created=$(get_creation_date "$file")
              
              # Extract current creation date from header
              current_created_line=$(grep -E "Created: [0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}" "$file" 2>/dev/null || echo "")
              current_created=""
              if [ -n "$current_created_line" ]; then
                current_created=$(echo "$current_created_line" | sed -E 's/.*Created: ([0-9]{4}\/[0-9]{2}\/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}).*/\1/')
              fi
              
              # Check if header format needs complete update
              header_lines=$(head -n 11 "$file")
              current_header_width=$(echo "$header_lines" | head -n 1 | wc -c)
              current_header_width=$((current_header_width - 1))
              
              needs_complete_update=false
              
              if [ "$current_header_width" -ne 85 ]; then
                needs_complete_update=true
                echo "   üîÑ Header format outdated (width: $current_header_width ‚Üí 85)"
              fi
              
              if [ -n "$current_created" ] && [ "$current_created" != "$accurate_created" ]; then
                needs_complete_update=true
                echo "   ‚ö†Ô∏è  Correcting creation date: $current_created ‚Üí $accurate_created"
              fi
              
              current_line=$(grep -m1 -E "/\*   .*:\+:" "$file" 2>/dev/null || echo "")
              if [ -n "$current_line" ]; then
                current_filename=$(echo "$current_line" | sed -E 's/\/\*   ([^ ]+).*/\1/')
                if [ "$current_filename" != "$filename" ]; then
                  needs_complete_update=true
                  echo "   üìù Correcting filename: $current_filename ‚Üí $filename"
                fi
              fi
              
              if [ "$needs_complete_update" = true ]; then
                final_created="$accurate_created"
                if [ -n "$current_created" ] && [ "$current_created" = "$accurate_created" ]; then
                  final_created="$current_created"
                fi
                
                new_header=$(printf "%s\n" \
                  "/* ********************************************************************************* */" \
                  "/*                                                                                   */" \
                  "/*                                                                :::      ::::::::  */" \
                  "/*   $filename                                               :+:      :+:    :+:  */" \
                  "/*                                                            +:+ +:+         +:+    */" \
                  "/*   By: $author <$header_email>         +#+  +:+       +#+      */" \
                  "/*                                                         +#+#+#+#+#+   +#+         */" \
                  "/*       Created: $final_created by $author            #+#    #+#           */" \
                  "/*       Updated: $updated by $author            ###   ########.fr    */" \
                  "/*                                                                                   */" \
                  "/* ********************************************************************************* */")
                
                new_header=$(echo "$new_header" | awk -v line="$new_line" '
                  /\/\*   .*:\+:/ {
                    print line
                    next
                  }
                  { print }
                ')
                
                temp_file=$(mktemp)
                echo "$new_header" > "$temp_file"
                printf "\n" >> "$temp_file"
                tail -n +12 "$file" >> "$temp_file"
                mv "$temp_file" "$file"
                
                echo "   ‚úÖ Header completely updated"
              else
                if ! git diff --quiet HEAD -- "$file" 2>/dev/null; then
                  sed -i -E \
                    -e "s|(Updated: )[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} by [^ ]+|\1$updated by $author|" \
                    "$file"
                  echo "   üìÖ Updated timestamp refreshed"
                fi
              fi
            else
              created=$(get_creation_date "$file")
              
              reference_header=$(printf "%s\n" \
                "/* ********************************************************************************* */" \
                "/*                                                                                   */" \
                "/*                                                                :::      ::::::::  */" \
                "/*   ft_putchar.c                                               :+:      :+:    :+:  */" \
                "/*                                                            +:+ +:+         +:+    */" \
                "/*   By: SoufianoDev <contact.devsoufiano@gmail.com>         +#+  +:+       +#+      */" \
                "/*                                                         +#+#+#+#+#+   +#+         */" \
                "/*       Created: 2025/06/17 02:01:35 by SoufianoDev            #+#    #+#           */" \
                "/*       Updated: 2025/06/17 01:01:51 by SoufianoDev            ###   ########.fr    */" \
                "/*                                                                                   */" \
                "/* ********************************************************************************* */")
              
              new_header=$(echo "$reference_header" | \
                sed -e "s|ft_putchar.c|${filename}|" \
                    -e "s|2025/06/17 02:01:35|${created}|" \
                    -e "s|2025/06/17 01:01:51|${updated}|")
              new_header=$(echo "$new_header" | awk -v line="$new_line" '
                /\/\*   .*:\+:/ {
                  print line
                  next
                }
                { print }
              ')
              temp_file=$(mktemp)
              echo "$new_header" > "$temp_file"
              printf "\n" >> "$temp_file"
              cat "$file" >> "$temp_file"
              mv "$temp_file" "$file"
              
              echo "   ‚úÖ New header added"
            fi
            
            # STEP 2: Apply comprehensive protected formatting
            echo "   üé® Applying comprehensive code protection and formatting..."
            format_42_code_minimal "$file"
            
            echo "   üéØ ‚úÖ Successfully processed: $filename"
            echo "   ================================================="
            
          done < <(find . -type f \( -name "*.c" -o -name "*.h" \) -print0)
          
          echo ""
          echo "üèÅ COMPLETED: Processed $file_count files with full code protection"
          echo "======================================================================="

      - name: Commit Changes
        uses: stefanzweifel/git-auto-commit-action@v6
        with:
          commit_message: "CI: Add 42 headers and format code "
          commit_user_name: "${{ github.actor }}"
          commit_user_email: "${{ github.actor }}@users.noreply.github.com"