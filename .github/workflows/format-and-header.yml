name: Update 42 Headers

on:
  push:
    branches: [main]

jobs:
  update-headers:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit to compare changes
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Get Changed and New Files
        id: changed-files
        run: |
          # Get list of modified and added .c and .h files in this push
          CHANGED_FILES=$(git diff --name-only --diff-filter=AM HEAD^ HEAD | grep -E '\.(c|h)$' || echo "")
          echo "changed_files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          if [ -n "$CHANGED_FILES" ]; then
            echo "Changed/Added C/H files found:"
            echo "$CHANGED_FILES"
          else
            echo "No C/H files changed or added in this push"
          fi

      - name: Process Headers
        if: steps.changed-files.outputs.changed_files != ''
        id: process-headers
        run: |
          set -eo pipefail
          author="SoufianoDev"
          header_email="contact.devsoufiano@gmail.com"
          updated=$(date +"%Y/%m/%d %H:%M:%S")
          target_length=85
          ref_filename="ft_putchar.c"
          ruler="/*   $ref_filename"
          template_line="$ruler                                               :+:      :+:    :+:  */"
          spaces_str=${template_line#"$ruler"}
          spaces_str=${spaces_str%%:+:*}
          reserved_space=${#spaces_str}
          suffix=":+:      :+:    :+:  */"

          # Arrays to track different types of changes
          updated_files=()
          new_header_files=()
          fixed_corrupted_files=()

          # Function to get the most accurate creation date
          get_creation_date() {
            local file="$1"
            local git_first_commit=""
            local filesystem_creation=""
            
            # Try to get first commit date from git history
            git_first_commit=$(git log --reverse --format="%ad" --date=format:"%Y/%m/%d %H:%M:%S" -- "$file" 2>/dev/null | head -n1 || echo "")
            
            # Get filesystem creation time (as fallback, but less reliable)
            if command -v stat >/dev/null 2>&1; then
              # Linux/Unix systems
              filesystem_creation=$(stat -c "%W" "$file" 2>/dev/null || echo "")
              if [ "$filesystem_creation" != "" ] && [ "$filesystem_creation" != "0" ]; then
                filesystem_creation=$(date -d "@$filesystem_creation" +"%Y/%m/%d %H:%M:%S" 2>/dev/null || echo "")
              else
                filesystem_creation=""
              fi
            fi
            
            # Prefer git history over filesystem metadata
            if [ -n "$git_first_commit" ]; then
              echo "$git_first_commit"
            elif [ -n "$filesystem_creation" ]; then
              echo "$filesystem_creation"
            else
              # Ultimate fallback to current date
              echo "$(date +"%Y/%m/%d %H:%M:%S")"
            fi
          }
          
          # Read changed files from the previous step
          changed_files="${{ steps.changed-files.outputs.changed_files }}"
          
          # Process only changed files
          echo "$changed_files" | while IFS= read -r file; do
            # Skip empty lines
            [ -z "$file" ] && continue
            
            # Skip if file doesn't exist (might be deleted)
            [ ! -f "$file" ] && continue
            
            echo "üîç Processing changed file: $file"
            
            filename=$(basename "$file")
            filename_len=${#filename}
            diff_len=$(( filename_len - ${#ref_filename} ))
            spaces_after=$(( reserved_space - diff_len ))
            (( spaces_after < 0 )) && spaces_after=0
            new_ruler="/*   $filename"
            new_line=$(printf "%s%*s%s" "$new_ruler" "$spaces_after" "" "$suffix")

            if head -n 1 "$file" | grep -q "/\* \*\*\*"; then
              # File already has header - check if it's valid or corrupted
              
              # Get the accurate creation date for comparison
              accurate_created=$(get_creation_date "$file")
              
              # Check if header is corrupted/invalid
              header_lines=$(head -n 11 "$file")
              current_header_width=$(echo "$header_lines" | head -n 1 | wc -c)
              current_header_width=$((current_header_width - 1))  # Remove newline character
              
              is_header_corrupted=false
              
              # Check if header width doesn't match required format (85 chars)
              if [ "$current_header_width" -ne 85 ]; then
                is_header_corrupted=true
                echo "‚ùå Header corrupted for $filename (invalid width: $current_header_width ‚â† 85)"
              fi
              
              # Check if filename in header is correct
              current_line=$(grep -m1 -E "/\*   .*:\+:" "$file" 2>/dev/null || echo "")
              if [ -n "$current_line" ]; then
                current_filename=$(echo "$current_line" | sed -E 's/\/\*   ([^ ]+).*/\1/')
                if [ "$current_filename" != "$filename" ]; then
                  is_header_corrupted=true
                  echo "‚ùå Header corrupted for $filename (wrong filename: $current_filename ‚â† $filename)"
                fi
              fi
              
              # Check if creation date format is correct
              current_created_line=$(grep -E "Created: [0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}" "$file" 2>/dev/null || echo "")
              if [ -z "$current_created_line" ]; then
                is_header_corrupted=true
                echo "‚ùå Header corrupted for $filename (invalid creation date format)"
              fi
              
              if [ "$is_header_corrupted" = true ]; then
                # Header is corrupted - REMOVE and REPLACE with new correct one
                echo "üóëÔ∏è  Removing corrupted header from $filename"
                echo "üîÑ Replacing with new compliant header"
                
                # Extract the original creation date from the existing header (if possible)
                original_created=""
                existing_created_line=$(grep -E "Created: [0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}" "$file" 2>/dev/null | head -n1 || echo "")
                if [ -n "$existing_created_line" ]; then
                  original_created=$(echo "$existing_created_line" | sed -E 's/.*Created: ([0-9]{4}\/[0-9]{2}\/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}).*/\1/')
                fi
                
                # Compare with Git creation date and use the accurate one if they don't match
                git_created=$(get_creation_date "$file")
                final_created="$original_created"
                
                if [ -n "$original_created" ] && [ "$original_created" != "$git_created" ]; then
                  echo "‚ö†Ô∏è  Creation date mismatch for $filename:"
                  echo "    Header date: $original_created"
                  echo "    Git date: $git_created"
                  echo "    Using Git date as the accurate one"
                  final_created="$git_created"
                elif [ -z "$original_created" ]; then
                  echo "üìÖ No valid creation date found in header, using Git date: $git_created"
                  final_created="$git_created"
                else
                  echo "‚úÖ Creation date matches Git history: $original_created"
                fi
                
                # Create new header with correct format and accurate creation date
                new_header=$(printf "%s\n" \
                  "/* ********************************************************************************* */" \
                  "/*                                                                                   */" \
                  "/*                                                                :::      ::::::::  */" \
                  "/*   $filename                                               :+:      :+:    :+:  */" \
                  "/*                                                            +:+ +:+         +:+    */" \
                  "/*   By: $author <$header_email>         +#+  +:+       +#+      */" \
                  "/*                                                         +#+#+#+#+#+   +#+         */" \
                  "/*       Created: $final_created by $author            #+#    #+#           */" \
                  "/*       Updated: $updated by $author            ###   ########.fr    */" \
                  "/*                                                                                   */" \
                  "/* ********************************************************************************* */")
                
                # Apply dynamic spacing for filename line
                new_header=$(echo "$new_header" | awk -v line="$new_line" '
                  /\/\*   .*:\+:/ {
                    print line
                    next
                  }
                  { print }
                ')
                
                # Replace the old corrupted header (first 11 lines) with new header
                temp_file=$(mktemp)
                echo "$new_header" > "$temp_file"
                printf "\n" >> "$temp_file"
                tail -n +12 "$file" >> "$temp_file"
                mv "$temp_file" "$file"
                
                echo "‚úÖ Corrupted header removed and replaced for $filename (creation date: $final_created)"
                fixed_corrupted_files+=("$filename")
              else
                # Header is valid - check if creation date matches Git history
                git_created=$(get_creation_date "$file")
                current_created_line=$(grep -E "Created: [0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}" "$file" 2>/dev/null | head -n1 || echo "")
                
                if [ -n "$current_created_line" ]; then
                  current_created=$(echo "$current_created_line" | sed -E 's/.*Created: ([0-9]{4}\/[0-9]{2}\/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}).*/\1/')
                  
                  if [ "$current_created" != "$git_created" ]; then
                    echo "‚ö†Ô∏è  Creation date correction needed for $filename:"
                    echo "    Header date: $current_created"
                    echo "    Git date: $git_created"
                    echo "    Correcting to match Git history"
                    
                    # Update both the creation date and the updated timestamp
                    sed -i -E \
                      -e "s|(Created: )[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} by [^ ]+|\1$git_created by $author|" \
                      -e "s|(Updated: )[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} by [^ ]+|\1$updated by $author|" \
                      "$file"
                    echo "‚úÖ Creation date corrected and timestamp updated for $filename"
                    updated_files+=("$filename")
                  else
                    # Creation date is correct, just update the timestamp
                    sed -i -E \
                      -e "s|(Updated: )[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} by [^ ]+|\1$updated by $author|" \
                      "$file"
                    echo "‚è∞ Valid header with correct creation date - Updated timestamp only for $filename"
                    updated_files+=("$filename")
                  fi
                else
                  # No valid creation date found, just update timestamp
                  sed -i -E \
                    -e "s|(Updated: )[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} by [^ ]+|\1$updated by $author|" \
                    "$file"
                  echo "‚è∞ Valid header - Updated timestamp only for $filename"
                  updated_files+=("$filename")
                fi
              fi
            else
              # File doesn't have header, create new one with accurate creation date
              created=$(get_creation_date "$file")
              
              # Create the reference header using printf to avoid YAML parsing issues
              reference_header=$(printf "%s\n" \
                "/* ********************************************************************************* */" \
                "/*                                                                                   */" \
                "/*                                                                :::      ::::::::  */" \
                "/*   ft_putchar.c                                               :+:      :+:    :+:  */" \
                "/*                                                            +:+ +:+         +:+    */" \
                "/*   By: SoufianoDev <contact.devsoufiano@gmail.com>         +#+  +:+       +#+      */" \
                "/*                                                         +#+#+#+#+#+   +#+         */" \
                "/*       Created: 2025/06/17 02:01:35 by SoufianoDev            #+#    #+#           */" \
                "/*       Updated: 2025/06/17 01:01:51 by SoufianoDev            ###   ########.fr    */" \
                "/*                                                                                   */" \
                "/* ********************************************************************************* */")
              
              new_header=$(echo "$reference_header" | \
                sed -e "s|ft_putchar.c|${filename}|" \
                    -e "s|2025/06/17 02:01:35|${created}|" \
                    -e "s|2025/06/17 01:01:51|${updated}|")
              new_header=$(echo "$new_header" | awk -v line="$new_line" '
                /\/\*   .*:\+:/ {
                  print line
                  next
                }
                { print }
              ')
              temp_file=$(mktemp)
              echo "$new_header" > "$temp_file"
              printf "\n" >> "$temp_file"
              cat "$file" >> "$temp_file"
              mv "$temp_file" "$file"
              echo "‚úÖ New header added for $filename"
              new_header_files+=("$filename")
            fi
          done

          # Save file lists to outputs for commit step
          printf "%s\n" "${updated_files[@]}" > updated_files.txt
          printf "%s\n" "${new_header_files[@]}" > new_header_files.txt  
          printf "%s\n" "${fixed_corrupted_files[@]}" > fixed_corrupted_files.txt

      - name: Commit and Push Changes
        if: steps.changed-files.outputs.changed_files != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Read the file lists
          updated_files=$(cat updated_files.txt 2>/dev/null || echo "")
          new_header_files=$(cat new_header_files.txt 2>/dev/null || echo "")  
          fixed_corrupted_files=$(cat fixed_corrupted_files.txt 2>/dev/null || echo "")

          # Function to create commit message based on file count
          create_commit_message() {
            local action="$1"
            local files="$2"
            local count=$(echo "$files" | grep -c . 2>/dev/null || echo 0)
            
            if [ "$count" -eq 0 ]; then
              return
            elif [ "$count" -eq 1 ]; then
              local filename=$(echo "$files" | head -n1)
              echo "ci: $action $filename"
            else
              echo "ci: $action headers for $count files"
            fi
          }

          # Check if there are any changes to commit
          if git diff --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Determine commit message based on what was done
          commit_messages=()
          
          if [ -n "$updated_files" ] && [ "$(echo "$updated_files" | grep -c .)" -gt 0 ]; then
            msg=$(create_commit_message "Update" "$updated_files")
            [ -n "$msg" ] && commit_messages+=("$msg")
          fi
          
          if [ -n "$new_header_files" ] && [ "$(echo "$new_header_files" | grep -c .)" -gt 0 ]; then
            msg=$(create_commit_message "Add header to" "$new_header_files")
            [ -n "$msg" ] && commit_messages+=("$msg")
          fi
          
          if [ -n "$fixed_corrupted_files" ] && [ "$(echo "$fixed_corrupted_files" | grep -c .)" -gt 0 ]; then
            msg=$(create_commit_message "Fix corrupted header in" "$fixed_corrupted_files")
            [ -n "$msg" ] && commit_messages+=("$msg")
          fi

          # Create final commit message
          if [ ${#commit_messages[@]} -eq 1 ]; then
            final_message="${commit_messages[0]}"
          elif [ ${#commit_messages[@]} -gt 1 ]; then
            final_message="ci: Update 42 headers - $(IFS='; '; echo "${commit_messages[*]#ci: }")"
          else
            final_message="ci: Update 42 headers"
          fi

          echo "Commit message: $final_message"
          
          # Add all changes and commit
          git add .
          git commit -m "$final_message"
          git push

          # Clean up temporary files
          rm -f updated_files.txt new_header_files.txt fixed_corrupted_files.txt