name: Update 42 Headers & Format Code (Safe Comment Protection)

on:
  push:
    branches: [main]

jobs:
  update-headers-and-format:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Install Python and c-formatter-42
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-pip
          pip3 install c-formatter-42

      - name: Process Headers and Format Code (Safe Comment Protection)
        run: |
          set -eo pipefail
          author="SoufianoDev"
          header_email="contact.devsoufiano@gmail.com"
          updated=$(date +"%Y/%m/%d %H:%M:%S")
          target_length=85
          ref_filename="ft_putchar.c"
          ruler="/*   $ref_filename"
          template_line="$ruler                                               :+:      :+:    :+:  */"
          spaces_str=${template_line#"$ruler"}
          spaces_str=${spaces_str%%:+:*}
          reserved_space=${#spaces_str}
          suffix=":+:      :+:    :+:  */"

          # Function to get the most accurate creation date
          get_creation_date() {
            local file="$1"
            local git_first_commit=""
            
            # Get first commit date from git history
            git_first_commit=$(git log --reverse --format="%ad" --date=format:"%Y/%m/%d %H:%M:%S" -- "$file" 2>/dev/null | head -n1 || echo "")
            
            # Use git history or fallback to current date
            if [ -n "$git_first_commit" ]; then
              echo "$git_first_commit"
            else
              echo "$(date +"%Y/%m/%d %H:%M:%S")"
            fi
          }

          # Enhanced Comment Protection Function (Header-Safe)
          protect_comments_safely() {
            local content="$1"
            local placeholders_file=$(mktemp)
            local counter=0
            local is_header_section="$2"  # true/false flag
            
            echo "üõ°Ô∏è  Starting safe comment protection (Header-aware)..."
            
            # If this is header section, use more restrictive protection
            if [ "$is_header_section" = "true" ]; then
              echo "üè∑Ô∏è  HEADER MODE: Protecting only non-header comments"
              
              # Only protect comments that are NOT part of the 42 header structure
              # Skip lines that match 42 header pattern
              local working_content="$content"
              
              # Protect single-line comments (// style) - these are safe
              while IFS= read -r line; do
                if echo "$line" | grep -q '//'; then
                  local comment_part=$(echo "$line" | sed 's|.*\(//.*\)|\1|')
                  if [ -n "$comment_part" ] && [ ${#comment_part} -gt 2 ]; then
                    local placeholder="__PROTECTED_COMMENT_${counter}__"
                    echo "$placeholder|$comment_part" >> "$placeholders_file"
                    working_content=$(echo "$working_content" | sed "s|$(echo "$comment_part" | sed 's/[[\.*^$()+?{|\\]/\\&/g')|$placeholder|g")
                    ((counter++))
                  fi
                fi
              done <<< "$content"
              
              # Protect multi-line comments that are NOT 42 header comments
              while read -r line; do
                if echo "$line" | grep -q '/\*' && ! echo "$line" | grep -q '\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*'; then
                  if ! echo "$line" | grep -q -E '^\s*/\*\s*$|^\s*\*\s*$|^\s*\*/\s*$'; then
                    # This is a regular comment, not a header comment
                    local comment_match=$(echo "$line" | grep -o '/\*.*\*/' || echo "")
                    if [ -n "$comment_match" ] && [ ${#comment_match} -gt 4 ]; then
                      local placeholder="__PROTECTED_COMMENT_${counter}__"
                      echo "$placeholder|$comment_match" >> "$placeholders_file"
                      working_content=$(echo "$working_content" | sed "s|$(echo "$comment_match" | sed 's/[[\.*^$()+?{|\\]/\\&/g')|$placeholder|g")
                      ((counter++))
                    fi
                  fi
                fi
              done <<< "$content"
              
            else
              echo "üíª CODE MODE: Protecting all comments"
              
              # Protect all comments in code section
              local working_content="$content"
              
              # Protect single-line comments
              while IFS= read -r line; do
                if echo "$line" | grep -q '//'; then
                  local comment_part=$(echo "$line" | sed 's|.*\(//.*\)|\1|')
                  if [ -n "$comment_part" ] && [ ${#comment_part} -gt 2 ]; then
                    local placeholder="__PROTECTED_COMMENT_${counter}__"
                    echo "$placeholder|$comment_part" >> "$placeholders_file"
                    working_content=$(echo "$working_content" | sed "s|$(echo "$comment_part" | sed 's/[[\.*^$()+?{|\\]/\\&/g')|$placeholder|g")
                    ((counter++))
                  fi
                fi
              done <<< "$content"
              
              # Protect multi-line comments
              local in_comment=false
              local comment_buffer=""
              local comment_start_placeholder=""
              
              while IFS= read -r line; do
                if echo "$line" | grep -q '/\*' && [ "$in_comment" = false ]; then
                  in_comment=true
                  comment_buffer="$line"
                  comment_start_placeholder="__PROTECTED_COMMENT_${counter}__"
                  
                  if echo "$line" | grep -q '\*/'; then
                    # Single line comment
                    local comment_match=$(echo "$line" | grep -o '/\*.*\*/')
                    if [ -n "$comment_match" ] && [ ${#comment_match} -gt 4 ]; then
                      echo "$comment_start_placeholder|$comment_match" >> "$placeholders_file"
                      working_content=$(echo "$working_content" | sed "s|$(echo "$comment_match" | sed 's/[[\.*^$()+?{|\\]/\\&/g')|$comment_start_placeholder|g")
                      ((counter++))
                    fi
                    in_comment=false
                    comment_buffer=""
                  fi
                elif [ "$in_comment" = true ]; then
                  comment_buffer="$comment_buffer"$'\n'"$line"
                  
                  if echo "$line" | grep -q '\*/'; then
                    # End of multi-line comment
                    if [ -n "$comment_buffer" ] && [ ${#comment_buffer} -gt 4 ]; then
                      echo "$comment_start_placeholder|$comment_buffer" >> "$placeholders_file"
                      local safe_comment=$(echo "$comment_buffer" | sed 's/[[\.*^$()+?{|\\]/\\&/g')
                      working_content=$(echo "$working_content" | sed "s|$safe_comment|$comment_start_placeholder|g")
                      ((counter++))
                    fi
                    in_comment=false
                    comment_buffer=""
                  fi
                fi
              done <<< "$content"
            fi
            
            echo "üéØ Protected $counter comments safely"
            echo "$working_content"
            echo "PLACEHOLDERS_FILE:$placeholders_file" >&2
          }

          # Comprehensive Code Elements Protection Function (Comment-Safe)
          protect_code_elements_safely() {
            local content="$1"
            local placeholders_file=$(mktemp)
            local counter=0
            
            echo "üõ°Ô∏è  Starting comprehensive code protection..."
            
            # Define code element patterns (excluding comment patterns)
            local protection_patterns=(
              # DATA TYPES
              '\bint\b' '\bchar\b' '\bfloat\b' '\bdouble\b' '\bvoid\b'
              '\blong\b' '\bshort\b' '\bunsigned\b' '\bsigned\b' '\bconst\b'
              '\bstatic\b' '\bextern\b' '\bregister\b' '\bvolatile\b' '\binline\b'
              '\bsize_t\b' '\bssize_t\b' '\bFILE\b' '\bt_[a-zA-Z_][a-zA-Z0-9_]*\b'
              
              # CONTROL STRUCTURES
              '\bif\b' '\belse\b' '\bswitch\b' '\bcase\b' '\bdefault\b'
              '\bwhile\b' '\bfor\b' '\bdo\b' '\bbreak\b' '\bcontinue\b'
              '\breturn\b' '\bgoto\b' '\btypedef\b' '\bstruct\b' '\bunion\b' '\benum\b'
              
              # PREPROCESSOR DIRECTIVES
              '^[ \t]*#[ \t]*include\b.*$'
              '^[ \t]*#[ \t]*define\b.*$'
              '^[ \t]*#[ \t]*if\b.*$'
              '^[ \t]*#[ \t]*ifdef\b.*$'
              '^[ \t]*#[ \t]*ifndef\b.*$'
              '^[ \t]*#[ \t]*endif\b.*$'
              
              # OPERATORS
              '\+\+' '\--' '\+=' '\-=' '\*=' '\/=' '%='
              '==' '!=' '<=' '>=' '&&' '\|\|'
              
              # STRING LITERALS
              '"([^"\\\\]|\\\\.)*"'
              "'([^'\\\\]|\\\\.)*'"
              
              # NUMERIC CONSTANTS
              '\b[0-9]+\.[0-9]*[fF]?\b'
              '\b[0-9]+[uUlL]*\b'
              '\b0[xX][0-9a-fA-F]+\b'
              
              # IDENTIFIERS (but not in comments)
              '\b[a-zA-Z_][a-zA-Z0-9_]*\b'
            )
            
            local working_content="$content"
            
            # Apply protection patterns
            for pattern in "${protection_patterns[@]}"; do
              local matches_found=0
              
              # Only protect matches that are NOT inside comments
              while IFS= read -r line; do
                # Skip lines that are comments
                if ! echo "$line" | grep -q -E '^\s*\/\*|^\s*\*|^\s*\/\/'; then
                  local match=$(echo "$line" | grep -oE "$pattern" | head -n1)
                  if [ -n "$match" ] && [ "$match" != " " ] && [ ${#match} -gt 1 ]; then
                    local placeholder="__PROTECTED_CODE_${counter}__"
                    echo "$placeholder|$match" >> "$placeholders_file"
                    
                    local safe_match=$(printf '%s\n' "$match" | sed 's/[[\.*^$()+?{|\\]/\\&/g')
                    working_content=$(echo "$working_content" | sed "0,/$safe_match/s//$placeholder/")
                    
                    ((counter++))
                    ((matches_found++))
                  fi
                fi
              done <<< "$(echo "$working_content" | grep -E "$pattern" 2>/dev/null || true)"
              
              if [ $matches_found -gt 0 ]; then
                echo "   ‚úì Protected $matches_found instances of: $pattern"
              fi
            done
            
            echo "üéØ Total protected code elements: $counter"
            echo "$working_content"
            echo "PLACEHOLDERS_FILE:$placeholders_file" >&2
          }

          # Universal Restoration Function
          restore_protected_elements() {
            local content="$1"
            local placeholders_file="$2"
            local restored_content="$content"
            local restored_count=0
            
            if [ -f "$placeholders_file" ] && [ -s "$placeholders_file" ]; then
              echo "üîì Restoring protected elements..."
              
              while IFS='|' read -r placeholder original; do
                if [ -n "$placeholder" ] && [ -n "$original" ]; then
                  if echo "$restored_content" | grep -q "$placeholder"; then
                    restored_content=$(echo "$restored_content" | sed "s|$placeholder|$original|g")
                    ((restored_count++))
                  fi
                fi
              done < "$placeholders_file"
              
              echo "‚úÖ Successfully restored $restored_count elements"
              rm -f "$placeholders_file"
            fi
            
            echo "$restored_content"
          }

          # Header-Safe Formatter
          format_with_header_protection() {
            local file="$1"
            local temp_file=$(mktemp)
            local header_content=""
            local code_content=""
            local comment_placeholders=""
            local code_placeholders=""
            
            echo "üé® Starting header-safe formatting for: $(basename "$file")"
            
            # STEP 1: Separate header from code
            if head -n 1 "$file" | grep -q "/\* \*\*\*"; then
              # Find header end
              local header_end_line=$(grep -n "/\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*/" "$file" | tail -n 1 | cut -d: -f1)
              
              if [ -n "$header_end_line" ] && [ "$header_end_line" -gt 0 ]; then
                local total_header_lines=$((header_end_line + 1))
                
                # Include empty line after header if present
                if sed -n "${total_header_lines}p" "$file" | grep -q "^$"; then
                  total_header_lines=$((total_header_lines + 1))
                fi
                
                header_content=$(head -n "$total_header_lines" "$file")
                code_content=$(tail -n +$((total_header_lines + 1)) "$file")
                
                echo "üè∑Ô∏è  Header separated (${total_header_lines} lines) - PROTECTED from formatting"
              else
                # Fallback
                header_content=$(head -n 12 "$file")
                code_content=$(tail -n +13 "$file")
                echo "üè∑Ô∏è  Header separated (12 lines) - PROTECTED from formatting"
              fi
            else
              echo "üìù No header detected - formatting entire file"
              header_content=""
              code_content=$(cat "$file")
            fi
            
            # STEP 2: Protect comments in code section ONLY
            local protected_code
            if [ -n "$code_content" ]; then
              protected_code=$(protect_comments_safely "$code_content" "false" 2>/tmp/comment_placeholders_stderr)
              comment_placeholders=$(grep "PLACEHOLDERS_FILE:" /tmp/comment_placeholders_stderr 2>/dev/null | cut -d: -f2- || echo "")
              
              # STEP 3: Protect other code elements
              protected_code=$(protect_code_elements_safely "$protected_code" 2>/tmp/code_placeholders_stderr)
              code_placeholders=$(grep "PLACEHOLDERS_FILE:" /tmp/code_placeholders_stderr 2>/dev/null | cut -d: -f2- || echo "")
            else
              protected_code=""
            fi
            
            # STEP 4: Apply minimal formatting (only to protected code)
            local formatted_code
            if [ -n "$protected_code" ]; then
              formatted_code=$(echo "$protected_code" | awk '
              BEGIN {
                indent_level = 0
              }
              
              # Skip empty lines
              /^[ \t]*$/ { 
                print ""
                next 
              }
              
              # Skip protected placeholders
              /^[ \t]*__PROTECTED_/ {
                print $0
                next
              }
              
              # Handle braces
              /{/ {
                gsub(/^[ \t]+/, "")
                for(i=0; i<indent_level; i++) printf "\t"
                print $0
                if (/{$/) indent_level++
                next
              }
              
              /}/ {
                if (/^[ \t]*}/) {
                  indent_level--
                  if (indent_level < 0) indent_level = 0
                }
                gsub(/^[ \t]+/, "")
                for(i=0; i<indent_level; i++) printf "\t"
                print $0
                next
              }
              
              # Other lines
              {
                gsub(/^[ \t]+/, "")
                if (length($0) > 0) {
                  for(i=0; i<indent_level; i++) printf "\t"
                  print $0
                } else {
                  print ""
                }
              }
              ')
            else
              formatted_code=""
            fi
            
            # STEP 5: Restore protected elements
            if [ -n "$code_placeholders" ]; then
              formatted_code=$(restore_protected_elements "$formatted_code" "$code_placeholders")
            fi
            
            if [ -n "$comment_placeholders" ]; then
              formatted_code=$(restore_protected_elements "$formatted_code" "$comment_placeholders")
            fi
            
            # STEP 6: Reassemble file (Header remains UNTOUCHED)
            if [ -n "$header_content" ]; then
              echo "üîó Reassembling: Protected Header + Formatted Code"
              {
                echo "$header_content"
                echo ""
                echo "$formatted_code"
              } > "$temp_file"
            else
              echo "üíæ Saving formatted code"
              echo "$formatted_code" > "$temp_file"
            fi
            
            # Replace original
            mv "$temp_file" "$file"
            
            # Cleanup
            rm -f /tmp/comment_placeholders_stderr /tmp/code_placeholders_stderr
            
            echo "‚úÖ Header-safe formatting completed"
          }

          # Main processing loop
          echo "üöÄ Starting header-safe processing..."
          echo "===================================="
          
          file_count=0
          while IFS= read -r -d '' file; do
            ((file_count++))
            echo ""
            echo "üìÅ File $file_count: $(basename "$file")"
            
            filename=$(basename "$file")
            filename_len=${#filename}
            diff_len=$(( filename_len - ${#ref_filename} ))
            spaces_after=$(( reserved_space - diff_len ))
            (( spaces_after < 0 )) && spaces_after=0
            new_ruler="/*   $filename"
            new_line=$(printf "%s%*s%s" "$new_ruler" "$spaces_after" "" "$suffix")

            # STEP 1: Process header (separate logic, well-tested)
            echo "   üè∑Ô∏è  Processing header..."
            if head -n 1 "$file" | grep -q "/\* \*\*\*"; then
              accurate_created=$(get_creation_date "$file")
              
              # Check if header needs update
              needs_update=false
              current_header_width=$(head -n 1 "$file" | wc -c)
              current_header_width=$((current_header_width - 1))
              
              if [ "$current_header_width" -ne 85 ]; then
                needs_update=true
                echo "   üîÑ Header width: $current_header_width ‚Üí 85"
              fi
              
              current_line=$(grep -m1 -E "/\*   .*:\+:" "$file" 2>/dev/null || echo "")
              if [ -n "$current_line" ]; then
                current_filename=$(echo "$current_line" | sed -E 's/\/\*   ([^ ]+).*/\1/')
                if [ "$current_filename" != "$filename" ]; then
                  needs_update=true
                  echo "   üìù Filename: $current_filename ‚Üí $filename"
                fi
              fi
              
              if [ "$needs_update" = true ]; then
                new_header=$(printf "%s\n" \
                  "/* ********************************************************************************* */" \
                  "/*                                                                                   */" \
                  "/*                                                                :::      ::::::::  */" \
                  "/*   $filename                                               :+:      :+:    :+:  */" \
                  "/*                                                            +:+ +:+         +:+    */" \
                  "/*   By: $author <$header_email>         +#+  +:+       +#+      */" \
                  "/*                                                         +#+#+#+#+#+   +#+         */" \
                  "/*       Created: $accurate_created by $author            #+#    #+#           */" \
                  "/*       Updated: $updated by $author            ###   ########.fr    */" \
                  "/*                                                                                   */" \
                  "/* ********************************************************************************* */")
                
                new_header=$(echo "$new_header" | awk -v line="$new_line" '
                  /\/\*   .*:\+:/ {
                    print line
                    next
                  }
                  { print }
                ')
                
                temp_file=$(mktemp)
                echo "$new_header" > "$temp_file"
                printf "\n" >> "$temp_file"
                tail -n +12 "$file" >> "$temp_file"
                mv "$temp_file" "$file"
                
                echo "   ‚úÖ Header updated"
              else
                # Only update timestamp if file changed
                if ! git diff --quiet HEAD -- "$file" 2>/dev/null; then
                  sed -i -E \
                    -e "s|(Updated: )[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} by [^ ]+|\1$updated by $author|" \
                    "$file"
                  echo "   üìÖ Timestamp updated"
                fi
              fi
            else
              # Add new header
              created=$(get_creation_date "$file")
              
              new_header=$(printf "%s\n" \
                "/* ********************************************************************************* */" \
                "/*                                                                                   */" \
                "/*                                                                :::      ::::::::  */" \
                "/*   $filename                                               :+:      :+:    :+:  */" \
                "/*                                                            +:+ +:+         +:+    */" \
                "/*   By: $author <$header_email>         +#+  +:+       +#+      */" \
                "/*                                                         +#+#+#+#+#+   +#+         */" \
                "/*       Created: $created by $author            #+#    #+#           */" \
                "/*       Updated: $updated by $author            ###   ########.fr    */" \
                "/*                                                                                   */" \
                "/* ********************************************************************************* */")
              
              new_header=$(echo "$new_header" | awk -v line="$new_line" '
                /\/\*   .*:\+:/ {
                  print line
                  next
                }
                { print }
              ')
              
              temp_file=$(mktemp)
              echo "$new_header" > "$temp_file"
              printf "\n" >> "$temp_file"
              cat "$file" >> "$temp_file"
              mv "$temp_file" "$file"
              
              echo "   ‚úÖ New header added"
            fi
            
            # STEP 2: Apply header-safe formatting
            echo "   üé® Applying header-safe formatting..."
            format_with_header_protection "$file"
            
            echo "   ‚úÖ Successfully processed: $filename"
            
          done < <(find . -type f \( -name "*.c" -o -name "*.h" \) -print0)
          
          echo ""
          echo "üèÅ COMPLETED: $file_count files processed with header-safe comment protection"

      - name: Commit Changes
        uses: stefanzweifel/git-auto-commit-action@v6
        with:
          commit_message: "ci: Update 42 headers and format code (header-safe comment protection)"
          commit_user_name: "${{ github.actor }}"
          commit_user_email: "${{ github.actor }}@users.noreply.github.com"